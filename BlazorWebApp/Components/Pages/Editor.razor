@page "/editor"
@page "/editor/{Id:guid}"
@rendermode InteractiveServer

@using TinyMCE.Blazor
@using BlazorWebApp.Models
@using BlazorWebApp.Services
@using Microsoft.AspNetCore.Components.Forms

@inject IPublicationService PublicationService
@inject ICategoryService    CategoryService
@inject NavigationManager   Nav

<h3>
  @(Id == null
      ? "New Publication"
      : (loadedExisting
          ? "Edit Publication"
          : "Unknown Publication – creating new"))
</h3>

<EditForm EditContext="editContext"
          OnValidSubmit="HandleSubmit">
  <DataAnnotationsValidator />
  <ValidationSummary />

  <!-- Category -->
  <div class="mb-3">
    <label class="form-label">Category</label>
    <InputSelect class="form-select" @bind-Value="dto.CategoryId">
      <option value="">-- None --</option>
      @foreach (var opt in categoryOptions)
      {
        <option value="@opt.Id">@opt.DisplayName</option>
      }
    </InputSelect>
    <ValidationMessage For="@(() => dto.CategoryId)" />
  </div>

  <!-- Title -->
  <div class="mb-3">
    <label class="form-label">Title</label>
    <InputText class="form-control" @bind-Value="dto.Title" />
    <ValidationMessage For="@(() => dto.Title)" />
  </div>

  <!-- TinyMCE Editor -->
  <div class="mb-3">
    <label class="form-label">Content</label>
    <TinyMCE.Blazor.Editor
      ApiKey="no-api-key"
      @bind-Value="dto.Html"
      Field="@(() => dto.Html)"
      Conf="@editorConfig" />
    <ValidationMessage For="@(() => dto.Html)" />
  </div>

  <!-- Buttons -->
  <button type="submit" class="btn btn-primary">Save Draft</button>
  <button type="button"
          class="btn btn-success ms-2"
          @onclick="PublishAsync"
          disabled="@(!canPublish)">
    Publish
  </button>
</EditForm>

@if (loadedExisting)
{
  <h4 class="mt-5">Revision History</h4>
  @if (revisions == null)
  {
    <p>Loading revisions…</p>
  }
  else if (!revisions.Any())
  {
    <p><em>No past revisions.</em></p>
  }
  else
  {
    <table class="table table-striped">
      <thead>
        <tr><th>When</th><th>Title</th><th></th></tr>
      </thead>
      <tbody>
        @foreach (var r in revisions)
        {
          <tr>
            <td>@r.CreatedAt.ToString("g")</td>
            <td>@r.Title</td>
            <td>
              <button class="btn btn-sm btn-outline-secondary"
                      @onclick="() => Restore(r.Id)">
                Restore
              </button>
            </td>
          </tr>
        }
      </tbody>
    </table>
  }
}

@code {
  [Parameter] public Guid? Id { get; set; }

  private PublicationWriteDto dto = new();
  private List<CategoryDto> categories = new();
  private List<(Guid Id, string DisplayName)> categoryOptions = new();
  private EditContext editContext = default!;
  private bool loadedExisting;
  private List<RevisionDto>? revisions;

  // Can publish only if title and content are non-empty
  private bool canPublish =>
    !string.IsNullOrWhiteSpace(dto.Title) &&
    !string.IsNullOrWhiteSpace(dto.Html);

  // TinyMCE configuration dictionary—with YouTube paste/embed support
  private readonly Dictionary<string, object> editorConfig = new()
  {
    ["height"] = 300,
    ["menubar"] = "file edit view insert format tools media table help",
    ["plugins"] = new[] { "link", "lists", "code", "image", "paste", "table", "media" },
    ["toolbar"] =
      "undo redo | bold italic underline | alignleft aligncenter | " +
      "bullist numlist | link image media | code",
    ["table_toolbar"] =
      "tableprops tabledelete | tableinsertrowbefore tableinsertrowafter | " +
      "tableinsertcolbefore tableinsertcolafter",
    ["images_upload_url"] = "/api/images/upload",
    ["automatic_uploads"] = true,
    ["paste_data_images"] = false,
    ["promotion"] = false,
    ["branding"] = false,

    // allow iframes through sanitizer
    ["extended_valid_elements"] = "iframe[src|width|height|frameborder|allowfullscreen]",

    // convert pasted YouTube links into embed iframes
    ["media_url_resolver"] = @"
function(data, resolve) {
    var youtubeMatch = data.url.match(/(?:youtu\.be\/|youtube\.com\/.*v=)([\w-_-]+)/);
    if (youtubeMatch) {
        var id = youtubeMatch[1];
        var embedUrl = 'https://www.youtube.com/embed/' + id;
        resolve({
            html: '<iframe width=""560"" height=""315"" src=""' + embedUrl + '"" frameborder=""0"" allowfullscreen></iframe>'
        });
    } else {
        resolve({ html: '' });
    }
}
"
  };

  protected override async Task OnInitializedAsync()
  {
    editContext = new EditContext(dto);
    categories = await CategoryService.ListAsync();
    categoryOptions.Clear();

    foreach (var cat in categories)
    {
      var ancestors = await CategoryService.GetAncestryAsync(cat.Id);
      var fullPath = string.Join(" > ",
                        ancestors.Select(a => a.Name)
                                 .Append(cat.Name));
      categoryOptions.Add((cat.Id, fullPath));
    }
    categoryOptions.Sort((a, b) =>
      string.Compare(a.DisplayName, b.DisplayName, StringComparison.CurrentCulture));

    if (Id.HasValue)
    {
      var existing = await PublicationService.GetAsync(Id.Value);
      if (existing != null)
      {
        loadedExisting = true;
        dto.CategoryId = existing.CategoryId;
        dto.Title = existing.Title;
        dto.Html = existing.Html;
        // load revisions
        revisions = await PublicationService.ListRevisionsAsync(Id.Value);
      }
    }
  }

private async Task HandleSubmit()
{
  if (loadedExisting && Id.HasValue)
  {
    await PublicationService.UpdateAsync(Id.Value, dto);
  }
  else
  {
    var created = await PublicationService.CreateAsync(dto);
    Id = created.Id;
    loadedExisting = true;
    // replace the URL so OnInitializedAsync will load our new Id
    Nav.NavigateTo($"/editor/{Id}", replace: true);
  }

  // AFTER either branch, refresh the history panel
  if (Id is Guid pubId)
    revisions = await PublicationService.ListRevisionsAsync(pubId);

  StateHasChanged();
}


  private async Task PublishAsync()
  {
    await HandleSubmit();
    if (loadedExisting && Id.HasValue)
    {
      await PublicationService.PublishAsync(Id.Value);
      Nav.NavigateTo($"/publications/{Id}");
    }
  }

  private async Task Restore(Guid revisionId)
  {
    var updated = await PublicationService.RestoreRevisionAsync(revisionId);
    // update the editor DTO
    dto.Title = updated.Title;
    dto.Html = updated.Html;
    dto.CategoryId = updated.CategoryId;

    // reload history
    if (Id is Guid pubId)
      revisions = await PublicationService.ListRevisionsAsync(pubId);
  }
}
